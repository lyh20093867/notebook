## 什么是架构
### 系统与子系统
#### 系统
系统泛指由一群有关联的个体组成，根据某种规则运作，能完成个别元件不能单独完成的工作的群体。它的意思是“总体”“整体”或“联盟”。
关联：系统是由一群有关联的个体组成的，没有关联的个体堆在一起不能成为一个系统。
规则：系统内的个体需要按照指定的规则运作，而不是单个个体各自为政。规则规定了系统内个体分工和协作的方式。
能力：系统能力与个体能力有本质的差别，系统能力不是个体能力之和，而是产生了新的能力
#### 子系统
子系统也是由一群有关联的个体所组成的系统，多半会是更大系统中的一部分。

### 模块与组件(零件)
模块和组件都是系统的组成部分，只是从不同的角度拆分系统而已。
从逻辑的角度来拆分系统后，得到的单元就是“模块”；从物理的角度来拆分系统后，得到的单元就是“组件”。划分模块的主要目的是职责分离；划分组件的主要目的是单元复用。
其实，“组件”的英文 component 也可翻译成中文的“零件”一词，“零件”更容易理解一些，“零件”是一个物理的概念，并且具备“独立且可替换”的特点。

### 框架与架构
#### 框架
软件框架（Software framework）通常指的是为了实现某个业界标准或完成特定基本任务的软件组件规范，也指为了实现某个软件组件规范时，提供规范所要求之基础功能的软件产品。
框架是组件规范：例如，MVC 就是一种最常见的开发规范，类似的还有 MVP、MVVM、J2EE 等框架。
框架提供基础功能的产品：例如，Spring MVC 是 MVC 的开发框架，除了满足 MVC 的规范，Spring 提供了很多基础功能来帮助我们实现功能，包括注解（@Controller 等）、Spring Security、Spring JPA 等很多基础功能。
#### 架构
软件架构指软件系统的“基础结构”，创造这些基础结构的准则，以及对这些结构的描述。
框架关注的是“规范”，架构关注的是“结构”。框架的英文是 Framework，架构的英文是 Architecture。

软件架构指软件系统的顶层结构。可以从业务逻辑的角度分解，也可以从物理部署的角度分解，还可以从开发规范的角度分解。

首先，“系统是一群关联个体组成”，这些“个体”可以是“子系统”“模块”“组件”等；架构需要明确系统包含哪些“个体”。
其次，系统中的个体需要“根据某种规则”运作，架构需要明确个体运作和协作的规则。
第三，维基百科定义的架构用到了“基础结构”这个说法，我改为“顶层结构”，可以更好地区分系统和子系统，避免将系统架构和子系统架构混淆在一起导致架构层次混乱。
IBM的4+1视图
### 总结
架构是顶层设计；框架是面向编程或配置的半成品；组件是从技术维度上的复用；模块是从业务维度上职责的划分；系统是相互协同可运行的实体。

## 架构的历史
### 历史背景
#### 机器语言（1940 年之前）
机器语言的主要问题是三难：太难写、太难读、太难改！
#### 汇编语言（20 世纪 40 年代）
汇编语言又叫“符号语言”，用助记符代替机器指令的操作码，用地址符号（Symbol）或标号（Label）代替指令或操作数的地址。
汇编语言不仅编写复杂，还有另外一个复杂的地方在于：不同 CPU 的汇编指令和结构是不同的。
#### 高级语言（20 世纪 50 年代）
Fortran LISP Cobol
#### 第一次软件危机与结构化程序设计（20 世纪 60 年代~20 世纪 70 年代）
IBM 的 System/360 的操作系统开发--->《人月神话》-->软件工程-->结构化编程-->模块化
结构化程序设计的主要特点是抛弃 goto 语句，采取“自顶向下、逐步细化、模块化”的指导思想。属于面向过程的设计思想

#### 第二次软件危机与面向对象（20 世纪 80 年代）
软件生产力远远跟不上硬件和业务的发展。第一次软件危机的根源在于软件的“逻辑”变得非常复杂，而第二次软件危机主要体现在软件的“扩展”变得非常复杂。
面向对象编程的思想产生并发展流行(C++，java,C#)

#### 软件架构(20世纪90年代)
90年代在Rational和mircosoft开始流行，有了组建

what ---> why----> how

## 架构设计目的
架构设计的主要目的是为了解决软件系统复杂度带来的问题。

### 复杂度分析


## 复杂度来源
### 高性能
软件系统中高性能带来的复杂度主要体现在两方面，一方面是单台计算机内部为了高性能带来的复杂度；另一方面是多台计算机集群为了高性能带来的复杂度

一是单台计算机内部为了高性能带来的复杂度；二是是多台计算机集群为了高性能带来的复杂度

#### 单机复杂度
计算机内部复杂度最关键的地方就是操作系统。
操作系统和性能最相关的就是进程和线程
人工输入--->批处理操作系统(计算机一次只能执行一个任务，cpu空闲)--->多进程，分时系统--->进程间通信的各种方式被设计出来了，包括管道、消息队列、信号量、共享存储等，但进程内部还是串行--->多线程，互斥锁
让多个cpu同时执行计算的方案通常有三种：SMP（Symmetric Multi-Processor，对称多处理器结构）、NUMA（Non-Uniform Memory Access，非一致存储访问结构）、MPP（Massive Parallel Processing，海量并行处理结构）。其中 SMP 是我们最常见的，目前流行的多核处理器就是 SMP 方案

#### 集群复杂度
##### 任务分配
1、增加了任务分配器；   
2、任务分配器和业务服务器之间的连接与交互；   
3、分配算法选择；  

##### 任务分解
业务越来越复杂，简单的通过任务分解，增加机器并不能带来显著的性能提升。
1、简单的系统更加容易做到高性能
2、可以针对单个任务进行扩展
逻辑任务拆分得太细反而会降低性能，因为这会指数级地增加系统间地调用，系统间地调用通过网络方式实现，远比系统内地函数调用低很多。

### 复杂度来源--高可用
系统无中断地执行其功能的能力，代表系统的可用性程度，是进行系统设计时的准则之一。
通过冗余来实现高可用；高性能增加机器目的在于“扩展”处理性能；高可用增加机器目的在于“冗余”处理单元。

#### 计算高可用
此处“计算”指的是业务的逻辑处理。计算有一个特点就是无论在哪台机器上进行计算，同样的算法和输入数据，产出的结果都是一样的。

#### 存储高可用
存储与计算相比，有一个本质上的区别：将数据从一台机器搬到到另一台机器，需要经过线路进行传输。线路传输的速度是毫秒级别，同一机房内部能够做到几毫秒；分布在不同地方的机房，传输耗时需要几十甚至上百毫秒。
意味着整个系统在某个时间点上，数据肯定是不一致的，按照"数据+逻辑=业务"的公式，如果数据不一致，即使逻辑一致，业务表现也是不一致的。
传输线路本身也存在可用性问题，传输线路可能中断、可能拥塞、可能异常（错包、丢包），并且传输线路的故障时间一般都特别长，短的十几分钟，长的几个小时都是可能的。

无论是正常情况下的传输延迟，还是异常情况下的传输中断，都会导致系统的数据在某个时间点或者时间段是不一致的，而数据的不一致又会导致业务问题，所以存储高可用的难点不在于如何备份数据，而在于如何减少或者规避数据不一致对业务造成的影响。

#### 高可用状态决策
无论是计算高可用还是存储高可用，其基础都是“状态决策”，即系统需要能够判断当前的状态是正常还是异常，如果出现了异常就要采取行动来保证高可用。
如果状态决策本身都是有错误或者有偏差的，那么后续的任何行动和处理无论多么完美也都没有意义和价值。
但在具体实践的过程中，恰好存在一个本质的矛盾：通过冗余来实现的高可用系统，状态决策本质上就不可能做到完全正确。
下面是常见的决策方式：
##### 独裁式
一个决策者多个上报者，该方式不会出现决策混乱的问题，但是因为只有一个决策者，存在决策者不可用的情况。

##### 协商式
最常用的协商式决策是主备决策；协商式决策架构不复杂，规则不复杂，难点为但是两者的信息交换出现问题时，状态决策怎么做。可以通过在两者之间增加多个连接降低连接中断对状态的影响，但是并不能彻底解决问题。

##### 民主式
民主式决策指的是多个独立的个体通过投票的方式来进行状态决策，按照"多数取胜"的规则确定最终的状态。ZooKeeper 集群在选举 leader 时就是采用这种方式，通过zab算法实现。
该方式算法复杂，也可能出现脑裂的问题，民主式决策的系统一般都采用“投票节点数必须超过系统总节点数一半”规则来解决脑裂的问题，但这种方式会降低可用性。

### 复杂度来源--可扩展性
可扩展性指系统为了应对将来需求变化而提供的一种扩展能力，当有新的需求出现时，系统不需要或者仅需要少量修改就可以支持，无须整个系统重构或者重建。
设计具备良好可扩展性的系统，有两个基本条件：正确预测变化、完美封装变化。

#### 预测变化
复杂性体现在：
1、不能每个设计点都考虑可扩展性。   
2、不能完全不考虑可扩展性。   
3、所有的预测都存在出错的可能性。   

#### 应对变化
第一种方式是通过剥离变化层和稳定层的方式应对变化，变化层和独立层各自独立，但会增加复杂性。

##### 系统需要拆分出变化层和稳定层

##### 需要设计变化层和稳定层之间的接口

第二种方式是提炼出抽象层和实现层，抽象层是稳定的，实现层可以根据具体的业务需要定制开发，通常包括设计模式和规则引擎。

设计模式的核心思想是封装变化，隔离可变性。





